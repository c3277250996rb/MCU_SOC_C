# A.代码



## 1.只有互斥锁时

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
static pthread_mutex_t mutex;
static int g_avail = 0;
/* 消费者线程 */
static void *consumer_thread(void *arg)
{
    for ( ; ; ) {
        pthread_mutex_lock(&mutex);//上锁
        while (g_avail > 0)
            g_avail--; //消费
        pthread_mutex_unlock(&mutex);//解锁
    }
    return (void *)0;
}


/* 主线程（生产者） */
int main(int argc, char *argv[])
{
    pthread_t tid;
    int ret;
    /* 初始化互斥锁 */
    pthread_mutex_init(&mutex, NULL);
    /* 创建新线程 */
    ret = pthread_create(&tid, NULL, consumer_thread, NULL);
    if (ret) {
        fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
        exit(-1);
    }
    for ( ; ; ) {
        pthread_mutex_lock(&mutex);//上锁
        g_avail++; //生产
        pthread_mutex_unlock(&mutex);//解锁
    }
    exit(0);
}

```

## 2.使用条件变量和互斥锁

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
static pthread_mutex_t mutex; //定义互斥锁
static pthread_cond_t cond; //定义条件变量
static int g_avail = 0; //全局共享资源
/* 消费者线程 */
static void *consumer_thread(void *arg)
{
    for ( ; ; ) {
        pthread_mutex_lock(&mutex);//上锁
        while (0 >= g_avail)
            pthread_cond_wait(&cond, &mutex);//等待条件满足
        while (0 < g_avail)
            g_avail--; //消费
        pthread_mutex_unlock(&mutex);//解锁
    }
    return (void *)0;
}


/* 主线程（生产者） */
int main(int argc, char *argv[])
{
    pthread_t tid;
    int ret;
    /* 初始化互斥锁和条件变量 */
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    /* 创建新线程 */
    ret = pthread_create(&tid, NULL, consumer_thread, NULL);
    if (ret) {
        fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
        exit(-1);
    }
    for ( ; ; ) {
        pthread_mutex_lock(&mutex);//上锁
        g_avail++; //生产
        pthread_mutex_unlock(&mutex);//解锁
        pthread_cond_signal(&cond);//向条件变量发送信号
    }
    exit(0);
}
```

## 3.性质

```C
	条件变量的主要操作便是发送信号（signal）和等待。发送信号操作即是通知一个或多个处于等待状态
的线程，某个共享变量的状态已经改变，这些处于等待状态的线程收到通知之后便会被唤醒，唤醒之后再检
查条件是否满足。等待操作是指在收到一个通知前一直处于阻塞状态。
	函数 pthread_cond_signal()和 pthread_cond_broadcast()均可向指定的条件变量发送信号，通知一个或多
个处于等待状态的线程。调用 pthread_cond_wait()函数是线程阻塞，直到收到条件变量的通知。
	pthread_cond_signal()和 pthread_cond_broadcast()函数原型如下所示： 
#include <pthread.h>
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);

	使用这些函数需要包含头文件<pthread.h>，参数 cond 指向目标条件变量，向该条件变量发送信号。调
用成功返回 0；失败将返回一个非 0 值的错误码。
	pthread_cond_signal()和 pthread_cond_broadcast()的区别在于：二者对阻塞于 pthread_cond_wait()的多个
线程对应的处理方式不同，pthread_cond_signal()函数至少能唤醒一个线程，而 pthread_cond_broadcast()函数
则能唤醒所有线程。使用 pthread_cond_broadcast()函数总能产生正确的结果，唤醒所有等待状态的线程，但
函数 pthread_cond_signal()会更为高效，因为它只需确保至少唤醒一个线程即可，所以如果我们的程序当中，
只有一个处于等待状态的线程，使用 pthread_cond_signal()更好，具体使用哪个函数根据实际情况进行选择！
	pthread_cond_wait()函数原型如下所示： 
#include <pthread.h>
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

	当程序当中使用条件变量，当判断某个条件不满足时，调用 pthread_cond_wait()函数将线程设置为等待
状态（阻塞）。pthread_cond_wait()函数包含两个参数：
	cond：指向需要等待的条件变量，目标条件变量；
	mutex：参数 mutex 是一个 pthread_mutex_t 类型指针，指向一个互斥锁对象；前面开头便给大家介绍
了，条件变量通常是和互斥锁一起使用，因为条件的检测（条件检测通常是需要访问共享资源的）是在互斥
锁的保护下进行的，也就是说条件本身是由互斥锁保护的。
	返回值：调用成功返回 0；失败将返回一个非 0 值的错误码。
	在 pthread_cond_wait()函数内部会对参数 mutex 所指定的互斥锁进行操作，通常情况下，条件判断以及
pthread_cond_wait()函数调用均在互斥锁的保护下，也就是说，在此之前线程已经对互斥锁加锁了。调用
pthread_cond_wait()函数时，调用者把互斥锁传递给函数，函数会自动把调用线程放到等待条件的线程列表
上，然后将互斥锁解锁；当 pthread_cond_wait()被唤醒返回时，会再次锁住互斥锁。
注意注意的是，条件变量并不保存状态信息，只是传递应用程序状态信息的一种通讯机制。如果调用
pthread_cond_signal()和 pthread_cond_broadcast()向指定条件变量发送信号时，若无任何线程等待该条件变量，
这个信号也就会不了了之。
	当调用 pthread_cond_broadcast()同时唤醒所有线程时，互斥锁也只能被某一线程锁住，其它线程获取锁
失败又会陷入阻塞。

```



# B.笔记

1.没有使用 pthread_cond_t 时, 当Consumer或Producer占用完一次资源后, 此时Consumer和Producer成为资源的下一次占用者的可能性是相等的, 但是为了性能的优化肯定是希望能让Producer占用这个资源后紧接着能让Consumer占用进行消费, Consumer占用这个资源后紧接着能让Producer占用进行生产.

2.如果 Producer占用这个资源后紧接着还是 Producer 进行占用的话无可厚非, 因为此处 Producer 默认的逻辑是生产得越多越好, 这也是为什么生产者不会去对资源进行判断.

3.如果 Consumer占用这个资源后紧接着还是 Consumer 进行占用的话会先加锁, 再判断资源是否有余(`while (g_avail > 0)`), 最后解锁资源, 理论上这种情况不可避免且消耗了无用的CPU.

4.但是使用了 pthread_cond_t  后,  当 Consumer 进行占用时, 会先循环进行 signal 的判断(`while (0 >= g_avail){pthread_cond_wait(&cond, &mutex);}`), 此时的资源:

- 如果上一次被 Producer 占用的话, Producer 占用完后会发送一个廉价的 signal , 此时的 Consumer 会通过 signal 的判断然后进行消费.
  - [综上] 上Producer(完成生产, signal: 1) =====> Consumer(完成消费, signal: 0)
- 如果上一次被 Consumer 占用的话:
  - 假设上一次的 Consumer 发现资源已经殆尽了从而 [无法消费] :
    - 但是由于上一次的 Consumer 发现资源殆尽之前, 会先对 signal 进行判断, 因为上一次发现殆尽, 说明上上一次是 Consumer 完成消费后并且 signal 已经无了, 说明上一次 Consumer 在判断 signal 时已经陷入阻塞导致进程休眠了, 也就不可能会发现资源殆尽了.
    - 上上Consumer(完成消费, signal: 0) =====> 上Consumer(无法消费, signal: 阻塞休眠) ==X==>...
    - 因此假设 [不成立] 
  - 假设上一次的 Consumer 发现资源存余并且已经 [完成消费] :
    - 由于上一次 Consumer 完成消费之前以及通过判断证实了 signal 还有, 说明上上一次是 Producer 完成了生产并发出了 signal , 由于默认的逻辑是 Producer 在生产时不会受到阻碍, 所以上上一次资源的占用者为 Producer 是默认成立的.
    - 上上Producer(完成生产, signal: 1) =====> 上Consumer(完成消费, signal: 0) =====>...
    - 因此假设 [成立] 
  - [综上] 上上Producer(完成生产, signal: 1) =====> 上Consumer(完成消费, signal: 0) =====> Consumer(无法消费, signal: 阻塞休眠)

# C.摘要

- [OFF] 条件变量
  - produce => consume => ...... => consumer => ...... => produce 
  - produce => consume => produce
- [ON] 条件变量
  - produce => consume => sleep => produce 
  - produce => consume => produce